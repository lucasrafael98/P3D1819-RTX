\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=3cm]{geometry}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsmath}
\graphicspath{ {./images/} }
\setlength{\parindent}{0.75cm} %heh, 0.75

\title{
    \textbf{Programação 3D - Assignment II}
    }
\author{
    \begin{Large}
        \textbf{Grupo 02}
    \end{Large}\\
    Francisco Campaniço 83463\\
    João Rafael 83482\\
    Rodrigo Oliveira 83558
}
\date{Março 2019}

\begin{document}

    \maketitle

    \section*{\textit{Uniform Grid Acceleration}}
        \par
        Para a grelha uniforme usa-se o algoritmo de Amanatides e Woo (1987). Este algoritmo inicializa a grid com um número de células dado por: 
        $$N\_cells_{ax} = \frac{M \cdot dim_{ax}}{(\frac{dim_x \cdot dim_y \cdot dim_z}{N\_obj})^{\frac{1}{3}}} + 1, ax = \{x,y,z\}$$
        $N\_obj$ sendo o número de objetos, $dim$ as dimensões da grelha, e $M$ um fator dado pelo utilizador (usa-se 2 por defeito).
        \par
        Após a criação das células, verifica-se que células é que contém cada objeto. Para isso, calculamos os índices das células correspondentes à \textit{Bounding Box} do objeto:
        $$i_{ax,min/max} = clamp(\frac{(obj\_bb_{ax} - grid\_bb_{ax,min/max})\cdot N\_cells_{ax}}{dim_{ax}},0,N\_cells_{ax} - 1), ax = \{x,y,z\}$$
        e percorremos todos os índices entre $i_{min}$ e $i_{max}$, preenchendo cada célula com ponteiros para os objetos contidos nela.
        \par
        Depois desta inicialização, começam-se a disparar raios sobre a grid, usando o algoritmo acima mencionado de \textit{grid traversal}, que consiste em ver a primeira célula onde o raio acerta, e calcular a trajetória do raio através da grid (ou seja, calcula-se os índices $tnext$, $step$ e $stop$).
        \par
        Finalmente, calcula-se para cada objeto na célula a interseção com o raio, e se não houver nenhuma interseção, ou a interseção tiver uma distância superior à distância até à próxima célula (ou seja, $tnear > tnext$), continua-se o atravessamento para a próxima célula. Este último caso deve-se ao facto de se há interseção mas é mais distante do que a célula atual, não há garantias que na verdade há uma interseção mais próxima, mas numa célula mais distante:
        \begin{center}
            \includegraphics[scale=0.7]{overlap} 
        \end{center}

        \subsection*{Extra: \textit{Mailboxes}}
            \par
            As mailboxes são uma otimização simples. Tem-se um \textit{ID} inteiro único para cada raio. Se esse raio testar a interseção com um objeto e o resultado for falso, adiciona-se ao objeto o \textit{ID}. Se o próximo raio a testar interseção com este objeto for o mesmo (ou seja, \textit{ID} igual), passa-se os cálculos de interseção à frente.
            \par
            Naturalmente, ter um \textit{ID} único não funciona muito bem com paralelização. Como tal, as \textit{mailboxes} são desligadas quando se tem a paralelização ligada.

        \subsection*{Extra: Paralelização}
            \par
	Mesmo com a \textit{Grid} observamos um pequeno uso da CPU em geral e chegamos a conclusão que recorrer à paralelização seria o ideal para tornar o processamento mais rápido. Logo, como em \textit{OpenGL} apenas uma \textit{Thread} pode ser a encarregada por desenhar (limitações de contexto) definimos um algoritmo para realizar a paralelização, no qual criamos \textit{threads} auxiliares que são encarregadas por calcular as cores de cada pixel para um número determinado de linhas. Ao calcular todas as cores de uma linha de pixels a informação é posta num \textit{buffer} (o qual é constantemente lido pela \textit{Main Thread} que desenha a linha em questão).
\par
	 Apesar de ter melhorado muito a performance notamos que algumas \textit{threads} acabavam muito antes de outras já que as linhas que lhes foram pré-designadas exigiam muito menos cálculos que outras, logo, introduzimos \textbf{\textit{Thread Scheduling}} na paralelização de forma a que todas as \textit{threads} que já terminaram as linhas que lhes tinham sido pré-designadas ajudem outras \textit{threads} calculando linhas que ainda não foram calculadas. Desta forma diminuimos \textbf{exponencialmente} o tempo de processamento final na maioria dos casos.
	\begin{center}
	\includegraphics[scale=0.65]{thread}
	\end{center}

        \subsection*{Resultados}
        Foram testadas várias cenas com as diferentes otimizações. O CPU usado foi um Intel i7-8750H com 6 \textit{cores} e 12 \textit{threads}.
        \begin{table}[h]
            \centering
            \begin{tabular}{|l|l|l|l|l|}
                \hline
                Teste                      & Sem Grid & Grid  & Grid + Mailboxes & Grid + Paralelização \\ \hline
                Balls (High)               & 12m14s   & 0m15s & 0m14s            & 1s500ms              \\ \hline
                Mount (Very High)          & 2h21m3s  & 0m32s & 0m29s            & 5s500ms              \\ \hline
                BFBoat (4000 triângulos)   & 14m45s   & 0m15s & 0m12s            & 1s700ms              \\ \hline
                Distant (3 esferas, DoFx32)& 0m29s    & 0m26s & 0m25s            & 5s300ms              \\ \hline
            \end{tabular}
        \end{table}


    \section*{\textit{Anti-Aliasing}}
        \subsection*{\textit{Jittering}}
            \par
	É uma técnica de \textit{Stochastic Sampling} que garante que os raios (número fixo) sejam aleatóriamente distribuídos. O pixel é subdividido em ${SAMPLES}$ subpixels e cada subpixel possui uma pequena perturbação tendo em conta a posição na \textit{Regular Grid de Subpixels}. De seguida, a soma das cores obtidas nos subpixels é normalizada. Sendo assim, cada subpixel tem a sua cor calculada da seguinte forma:
	\par
	\begin{center}
	\includegraphics[scale=0.65]{jittering}
	\includegraphics[scale=0.65]{jittering2}
	\end{center}
	\par
	Onde ${\varepsilon}$ representa um número aleatório uniforme entre 0 e 1.
        \subsection*{\textit{Monte Carlo Super Sampling}}
            \par
	É uma técnica de \textit{Super Sampling} recursiva que tem como vantagem principal o número reduzido de raios disparados. O primeiro passo é disparar quatro raios no pixel (um em cada canto) e de seguida verifica-se se as cores são todas similares entre si através de uma diferença que respeite um \textit{threshold} determinado. Em caso positivo, a cor do pixel é a média dos quatro cantos. Em caso negativo, o pixel é separado em quatro sub-pixels (disparar mais cinco raios, um em cada canto e um ao centro) e aplica-se a mesma técnica em recursão até atingir um limite de sub-pixels determinado ou até atingir finalmente cores similares. 
	\par
	O resultado é filtrado fazendo médias dos resultados em cada passo de recursão nos sub-pixels, ou seja, a cor final do pixel é a média das cores calculadas em recursão.
	\begin{center}
	\includegraphics[scale=0.40]{montecarlo}
	\end{center}

	\par
	É notável que a imagem feita com \textit{Jittering} possui um resultado mais agradável e real por causa da \textit{edge sharpness} apresentada, no entanto, a imagem feita com \textit{Monte Carlo Super Sampling} exige menos tempo de processamento.

        \begin{figure}[h!]
            \centering
            \includegraphics[scale=0.08]{aa00}
            \includegraphics[scale=0.08]{aajt}
            \includegraphics[scale=0.08]{aamc}
            \caption{\textit{AA} desligado, \textit{Jittering} com 3 \textit{samples}, \textit{Monte Carlo super sampling}.}
        \end{figure}    

    \section*{\textit{Soft Shadows}}
        \subsection*{\textit{Random}}
            \par
	Neste método tratamos \textit{Area Lights} como infinitos pontos de luz e selecionamos um destes pontos de forma aleatória. Para atingir este resultado, apenas provocamos uma perturbação nas componentes \textit{X} e \textit{Y} de cada ponto de luz multiplicando estas por um número aleatório entre 0 e 1.
        \subsection*{\textit{Area Light}}
            \par
            Este método baseia-se em simular as luzes como áreas em vez de \textit{pointlights}. Para isto, calculam-se "posições alternativas" para cada luz, que consistem de um deslocamento da posição de cada luz dentro de uma área definida previamente, e com um pouco de \textit{jittering}:
            $$ light\_alternate\_pos = \{x + \frac{p + rand}{samples * area}, y + \frac{q + rand}{samples * area}, z\}, p,q \in \{0, samples - 1\},$$
            $rand$ sendo um valor aleatório entre 0 e 1. Após calcular estas posições, da-se \textit{shuffle} ao vetor que as contém, para que cada pixel \textit{jittered} não teste as sombras com a sua posição correspondente:
            \begin{figure}[h]
                \centering
                \includegraphics[scale=0.5]{area} 
            \end{figure}
            \begin{figure}[h]
                \centering
                \includegraphics[scale=0.06]{ssoff}
                \includegraphics[scale=0.06]{ssrd}
                \includegraphics[scale=0.06]{ssal1}
                \includegraphics[scale=0.06]{ssal2}
                \caption{\textit{SS} desligadas, \textit{Random}e \textit{Area light} com a área a 0.25 e 0.5.}
            \end{figure}    

        
    \section*{\textit{Depth of Field}}
        \par
        Para fazer o \textit{depth of field} começámos por alterar os raios primários de acordo com a flag \textit{DOF\_ON} que nos diz se a opção desta especificação está ativada. Dentro dessa condição, primeiro calculamos um ponto aleatório numa área circular de acordo com a abertura e metemos esse ponto em coordenadas do mundo, de forma a ser usado como origem do novo raio primário.
        \par
        Em segundo lugar calculamos o ponto correspondente ao pixel no plano de visualização com as componentes da cena \textit{w}, \textit{h} e \textit{df}. Com este ponto podemos usar a distância focal dada como parâmetro e o componente \textit{df} para encontrar o ponto correspondente no plano focal.
        \par
        Finalmente usamos o ponto da área circular e o do plano focal para calcular a direção do novo raio primário, como demonstrado na seguinte equação:
        \begin{equation*}
        \begin{aligned}
        d_{\mathrm{r}} &=p-l_{\mathrm{s}} \\ &=\left(p_{x}-l_{\mathrm{s}}\right) u+\left(p_{y}-l_{\mathrm{sy}}\right) v-f w 
        \end{aligned}
        \end{equation*}
        \par
        Para obter vários pontos aletórios na área circular é feito um ciclo com um número especificado de vezes como parâmetro, na criação dos raios primários e depois é feita a média das cores devolvidas por esse raios primários. No caso de \textit{jittering}, é feito o ciclo mencionado em cima, dentro da iteração quadrática de \textit{jittering}.
        \begin{figure}[h]
            \centering
            \includegraphics[scale=0.08]{dof1}
            \includegraphics[scale=0.08]{dof20}
            \includegraphics[scale=0.08]{dof100}
            \caption{\textit{DoF} desligado, com a abertura a 20, e a 100.}
        \end{figure}  

    \section*{Extras}  
        \subsection*{Ficheiros PLY}
            \par
            Para conseguir importar ficheiros com extensão \textit{.ply} tentámos juntar as funcionalidades da extensão \textit{.nff}, de forma a obter as componentes dos materiais para cada objeto. Por isso continuamos a usar ficheiros \textit{.nff} mas cada objecto \textit{.ply} pode ser referenciado dentro desse ficheiro. Assim torna-se possível usar os materiais já enunciados para os ficheiros \textit{.ply} que forem ncessários. A figura 4 mostra dois exemplos deste ficheiros:
            \begin{figure}[h!]
                \centering
                \includegraphics[scale=0.122]{apple}
                \includegraphics[scale=0.122]{boat}
                \caption{Dois exemplos de cenas com ficheiros PLY.}
            \end{figure} 

        \subsection*{\textit{Glossy Reflections}}  
            \par
	As \textit{Glossy Reflections} seguem a fórmula de cálculo de uma \textit{Area Light}. Ao invés de obter a cor de uma reflexão a partir de apenas um raio, disparamos mais ${SAMPLES}$ raios com direções levemente alteradas de forma a apontar para uma área em volta da direção original. A cor resultante de uma reflexão é, então, a média das cores calculadas pelos raios com direções levemente alteradas e do raio principal.
            \begin{figure}[h!]
                \centering
                \includegraphics[scale=0.122]{glrefl}
                \caption{\textit{Glossy Reflections} com 2 \textit{samples}.}
            \end{figure}
\end{document}